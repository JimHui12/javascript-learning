<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!--
        原型链:
            访问一个对象的属性时，
                先在自身属性中查找，找到返回
                如果没有，再沿着__proto__这条链向上查找，找到返回
                如果最终没有找到，返回undefined
            别名: 隐式原型链--查找对象属性
            作用：查找对象的属性(方法)
        
        1.构造函数/原型/实体对象的类型
            var o1 = new Object()
            var o2 = {}
            两个实例对象中有__proto__隐式原型属性指向Object的原型对象
        
        
        2.构造函数/原型/实体对象的关系 
            实例对象的隐式原型等于构造函数的显式原型
            function Foo(){}
            var Foo = new Function()
            Function = new Function()
            所有函数的__proto__都是一样的，都指向Function的显式原型

        3.原型继承: 
            构造函数的实例对象自动拥有构造函数原型对象的属性(方法)，原型上的属性和方法给实例用
            利用的就是原型链


      -->

    <script>
        //console.log(Object);
        //console.log(Object.prototype);
        console.log(Object.prototype.__proto__);
        function Fn(){
            this.test1 = function(){
                console.log('test1()');
            }
        }
        console.log(Fn.prototype);
        Fn.prototype.test2 = function() {
            console.log('test2()');
        }

        var fn = new Fn();

        fn.test1()
        fn.test2()
        console.log(fn.toString());
        console.log(fn.test3);
        // fn.test3();
        
        // test3()

        /*
        1. 函数的显式原型指向的对象:默认是空Object实例对象(但Object 不满足)
        */ 
        console.log(Fn.prototype instanceof Object); //true
        console.log(Object.prototype instanceof Object); //false
        console.log(Function.prototype instanceof Object); //true
        /*
        2. 所有函数都是Function的函数(包括Function本身)
        */
        console.log(Function.__proto__===Function.prototype);
        
        /*
        3.Object的原型对象是原型链尽头
        */ 
        console.log(Object.prototype.__proto__); //null

    </script>  
</body>
</html>